#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "isa.h"

#define MAX_LINE_LEN 256
#define MAX_LABEL_LEN 64

struct Label
{
  char name[MAX_LABEL_LEN];
  int address;
  struct Label *next;
} *label_table = NULL;

struct ParsedInstruction
{
  int op;
  char arg[64];
  int expects_arg;
  struct ParsedInstruction *next;
} *instructions = NULL;

/**
 * write_int32 - Writes a 32-bit integer to a file in little-endian format
 * @param f The output file pointer
 * @param val The integer value to write
 */
void write_int32(FILE *f, int val)
{
  unsigned char bytes[4];
  bytes[0] = (val >> 0) & 0xFF;
  bytes[1] = (val >> 8) & 0xFF;
  bytes[2] = (val >> 16) & 0xFF;
  bytes[3] = (val >> 24) & 0xFF;
  fwrite(bytes, 1, 4, f);
}

/**
 * trim_whitespace - Trims leading and trailing whitespace from a string
 * @param str The input string to trim
 *
 * @return A pointer to the trimmed string (modified in-place)
 */
char *trim_whitespace(char *str)
{
  // Trim leading whitespace
  while (isspace((unsigned char)*str))
    str++;

  // Check if all characters are whitespace
  if (*str == 0)
    return str;

  // Trim trailing whitespace
  char *end = str + strlen(str) - 1;
  while (end > str && isspace((unsigned char)*end))
    end--;

  end[1] = '\0';
  return str;
}

/**
 * has_argument - Checks if an opcode requires an argument
 * @param opcode The opcode integer
 *
 * @return 1 if the opcode requires an argument, 0 otherwise
 */
int has_argument(int opcode)
{
  switch (opcode)
  {
  case OP_PUSH:
  case OP_JMP:
  case OP_JZ:
  case OP_JNZ:
  case OP_STORE:
  case OP_LOAD:
  case OP_CALL:
    return 1;
  default:
    return 0;
  }
}

/**
 * get_opcode - Returns the opcode integer for a given mnemonic string
 * @param mnemonic The instruction mnemonic (e.g., "PUSH", "ADD")
 *
 * @return The opcode integer, or -1 if the mnemonic is invalid
 */
int get_opcode(const char *mnemonic)
{
  if (strcmp(mnemonic, "PUSH") == 0)
    return OP_PUSH;
  if (strcmp(mnemonic, "POP") == 0)
    return OP_POP;
  if (strcmp(mnemonic, "DUP") == 0)
    return OP_DUP;
  if (strcmp(mnemonic, "HALT") == 0)
    return OP_HALT;
  if (strcmp(mnemonic, "ADD") == 0)
    return OP_ADD;
  if (strcmp(mnemonic, "SUB") == 0)
    return OP_SUB;
  if (strcmp(mnemonic, "MUL") == 0)
    return OP_MUL;
  if (strcmp(mnemonic, "DIV") == 0)
    return OP_DIV;
  if (strcmp(mnemonic, "CMP") == 0)
    return OP_CMP;
  if (strcmp(mnemonic, "JMP") == 0)
    return OP_JMP;
  if (strcmp(mnemonic, "JZ") == 0)
    return OP_JZ;
  if (strcmp(mnemonic, "JNZ") == 0)
    return OP_JNZ;
  if (strcmp(mnemonic, "STORE") == 0)
    return OP_STORE;
  if (strcmp(mnemonic, "LOAD") == 0)
    return OP_LOAD;
  if (strcmp(mnemonic, "CALL") == 0)
    return OP_CALL;
  if (strcmp(mnemonic, "RET") == 0)
    return OP_RET;
  return -1;
}

/**
 * get_label_addr - Retrieves the address of a label from the label table
 * @param name The label name to search for
 *
 * @return The address (byte offset) of the label, or -1 if not found
 */
int get_label_addr(const char *name)
{
  struct Label *current = label_table;
  while (current != NULL)
  {
    if (strcmp(current->name, name) == 0)
    {
      return current->address;
    }
    current = current->next;
  }
  return -1;
}

/**
 * free_labels - Frees all labels in the label table
 * Iterates through the label linked list and frees all allocated memory.
 */
void free_labels()
{
  while (label_table != NULL)
  {
    struct Label *next_label = label_table->next;
    free(label_table);
    label_table = next_label;
  }
}

/**
 * add_label - Adds a label to the label table
 * @param name The label name
 * @param addr The address (byte offset) associated with the label
 *
 * Checks for table overflow and duplicate labels, exits on error.
 */
void add_label(const char *name, int addr)
{
  // Check for duplicates
  if (get_label_addr(name) != -1)
  {
    fprintf(stderr, "Error: Duplicate label '%s'\n", name);
    exit(1);
  }

  // Add label to table
  struct Label *new_label = (struct Label *)malloc(sizeof(struct Label));
  if (!new_label)
  {
    fprintf(stderr, "Error: Memory allocation failed for label '%s'\n", name);
    exit(1);
  }

  strncpy(new_label->name, name, MAX_LABEL_LEN);
  new_label->address = addr;
  new_label->next = label_table;
  label_table = new_label;
}

/**
 * check_label_definition - Checks and processes label definitions in assembly lines
 * @param clean The trimmed assembly line to parse
 * @param current_byte The current byte offset in the generated bytecode
 *
 * Searches for a colon (':') which indicates a label definition. If found, extracts
 * the label name and validates it (must contain only alphanumeric characters and '_').
 * Adds the label to the label table with its corresponding byte address, then returns
 * the remaining instruction part of the line (if any).
 *
 * Exits on error conditions:
 * - Memory allocation failures
 * - Invalid label names (non-alphanumeric characters except '_')
 *
 * @return A pointer to the instruction part after the label (or the original string
 *         if no label definition is found). Caller should not free the returned pointer
 *         if it equals the input, but should free it if it's a newly allocated string.
 */
int check_label_definition(char *clean, int current_byte)
{
  // Check for label definition
  char *colon = strchr(clean, ':');
  if (!colon)
  {
    return 0;
  }

  // Copy instruction part after the colon
  char *instruction = malloc(strlen(colon));
  if (!instruction)
  {
    fprintf(stderr, "Error: Memory allocation failed while parsing label\n");
    exit(1);
  }
  strncpy(instruction, colon + 1, strlen(colon));

  // Scan to see if the line starts with a valid label (Alphanumeric + '_')v
  *colon = '\0';
  clean = trim_whitespace(clean);
  char *ptr = clean;
  while (*ptr)
  {
    if (!isalnum((unsigned char)*ptr) && *ptr != '_')
    {
      fprintf(stderr, "Error: Invalid label name '%s'\n", clean);
      exit(1);
    }
    ptr++;
  }

  // Add label to table and return the instruction part
  add_label(clean, current_byte);
  strcpy(clean, trim_whitespace(instruction));
  free(instruction);
  return 1;
}

/**
 * parse_instructions - Parses assembly instructions from input file
 * @param in The input file pointer to read assembly source code from
 *
 * Performs first-pass assembly: reads assembly source code, identifies labels,
 * and parses instructions. Handles comments (lines starting with ';'), whitespace,
 * and validates opcodes and arguments. Updates the label table with label addresses
 * and builds a linked list of parsed instructions.
 *
 * Exits on error conditions:
 * - Unknown instruction mnemonics
 * - Missing required arguments for instructions that expect them
 * - Memory allocation failures
 *
 * @return The total number of bytes that will be generated by the instructions
 *         (1 byte per opcode + 4 bytes per argument)
 */
int parse_instructions(FILE *in)
{
  char line[MAX_LINE_LEN];
  int current_byte = 0;
  int line_num = 0;
  struct ParsedInstruction *tail = NULL;

  while (fgets(line, sizeof(line), in))
  {
    // Remove comments
    line_num++;
    char *ptr = strchr(line, ';');
    if (ptr)
      *ptr = '\0';

    // Trim whitespace and skip empty lines
    char *clean = trim_whitespace(line);
    if (strlen(clean) == 0)
      continue;

    // Check for Label and add to table if found
    int is_label = check_label_definition(clean, current_byte);
    if (is_label && strlen(clean) == 0)
    {
      continue;
    }

    // Ensure line ends with semicolon
    if (!ptr)
    {
      fprintf(stderr, "Missing semicolon at line %d\n", line_num);
      exit(1);
    }

    // Parse Instruction
    char mnemonic[16];
    char arg_str[64] = {0};
    int items = sscanf(clean, "%s %63s", mnemonic, arg_str);

    int op = get_opcode(mnemonic);
    if (op == -1)
    {
      fprintf(stderr, "Unknown instruction '%s' at line %d\n", mnemonic, line_num);
      exit(1);
    }

    // Update current byte offset
    int expects_arg = has_argument(op);
    if (expects_arg && items < 2)
    {
      fprintf(stderr, "Missing argument for '%s' at line %d\n", mnemonic, line_num);
      exit(1);
    }

    struct ParsedInstruction *new_inst = malloc(sizeof(struct ParsedInstruction));
    if (!new_inst)
    {
      fprintf(stderr, "Error: Memory allocation failed for instruction '%s' at line %d\n", mnemonic, line_num);
      exit(1);
    }

    new_inst->op = op;
    new_inst->expects_arg = expects_arg;
    new_inst->next = NULL;

    if (items >= 2)
    {
      strncpy(new_inst->arg, arg_str, sizeof(new_inst->arg));
      new_inst->arg[sizeof(new_inst->arg) - 1] = '\0';
    }
    else
    {
      new_inst->arg[0] = '\0';
    }

    if (instructions == NULL)
    {
      instructions = new_inst;
    }
    else
    {
      tail->next = new_inst;
    }

    tail = new_inst;
    current_byte += 1;
    if (expects_arg)
    {
      current_byte += 4;
    }
  }

  return current_byte;
}

/**
 * assemble - Assembles an assembly language source file into bytecode
 * @param in The input file pointer to read assembly source code from
 * @param out The output file pointer to write compiled bytecode to
 *
 * Performs two-pass assembly: first pass collects labels, second pass
 * generates bytecode. Supports mnemonics with optional arguments and
 * label references. Exits on parsing or validation errors.
 *
 * @return The total number of bytes written to the output file
 */
int assemble(FILE *in, FILE *out)
{
  int current_byte = parse_instructions(in);
  while (instructions != NULL)
  {
    struct ParsedInstruction *next_instr = instructions->next;
    int op = instructions->op;
    fputc(op, out);

    if (instructions->expects_arg)
    {
      int value = get_label_addr(instructions->arg);
      if (value == -1)
      {
        value = atoi(instructions->arg);
      }
      write_int32(out, value);
    }
    free(instructions);
    instructions = next_instr;
  }

  free_labels();
  return current_byte;
}

/**
 * main - Entry point for the assembler program
 * @param argc The number of command-line arguments
 * @param argv The command-line arguments (program name, source file, output file)
 *
 * Assembles an assembly language source file into bytecode binary.
 * Usage: assembler <source.asm> <output.bin>
 *
 * @return 0 on success, 1 on failure
 */
int main(int argc, char *argv[])
{
  char *out_file = "a.bin"; // Default output file name
  if (argc < 2)
  {
    printf("Usage: %s <source.asm> [<output.bin>]\n", argv[0]);
    return 1;
  }
  if (argc > 2)
  {
    out_file = argv[2];
  }

  FILE *in = fopen(argv[1], "r");
  if (!in)
  {
    perror("Error opening source file");
    return 1;
  }

  FILE *out = fopen(out_file, "wb");
  if (!out)
  {
    perror("Error opening output file");
    fclose(in);
    return 1;
  }

  int current_byte = assemble(in, out);
  fclose(in);
  fclose(out);
  printf("Assembly complete: %s -> %s (%d bytes)\n", argv[1], argv[2], current_byte);
  return 0;
}
